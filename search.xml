<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[括号匹配]]></title>
    <url>%2F2018%2F10%2F19%2F%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[数据结构作业 在编写代码的时候，经常会用到两种括号：圆括号 “()” 和大括号 “{}” 。不管使用哪种括号，程序编译没有问题的其中一个重要因素就是所使用的括号是否能够匹配上. 在编写程序时，括号可以嵌套，即： “({()})” 这种形式，但 “({)” 或者 “({}” 都不符合要求。 括号匹配项目要求：给出任意搭配的括号，判断是否匹配。 设计思路编写程序判断括号匹配问题的时候，使用栈结构会很容易： 如果碰到的是左圆括号或者左大括号，直接压栈；如果碰到的是右圆括号或者右大括号，就直接和栈顶元素配对：如果匹配，栈顶元素弹栈；反之，括号不匹配； 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;int top=-1;//top变量时刻表示栈顶元素所在位置void push(char * a,int elem)&#123; a[++top]=elem;&#125;void pop(char* a)&#123; if (top==-1) &#123; return ; &#125; top--;&#125;char visit(char * a)&#123; //调取栈顶元素，不等于弹栈，如果栈为空，为使程序不发生错误，返回空字符 if (top!=-1) &#123; return a[top]; &#125;else&#123; return &apos; &apos;; &#125;&#125;int main() &#123; char a[30]; char bracket[100]; printf(&quot;请输入括号序列：&quot;); scanf(&quot;%s&quot;,bracket); getchar(); int length=(int)strlen(bracket); for (int i=0; i&lt;length; i++) &#123; //如果是左括号，直接压栈 if (bracket[i]==&apos;(&apos;||bracket[i]==&apos;&#123;&apos;) &#123; push(a, bracket[i]); &#125;else&#123; //如果是右边括号，判断与栈顶元素是否匹配，如果匹配，栈顶元素弹栈，程序继续运行；否则，发现括号不匹配，输出结果直接退出 if (bracket[i]==&apos;)&apos;) &#123; if (visit(a)==&apos;(&apos;) &#123; pop(a); &#125;else&#123; printf(&quot;括号不匹配&quot;); return 0; &#125; &#125;else&#123; if (visit(a)==&apos;&#123;&apos;) &#123; pop(a); &#125;else&#123; printf(&quot;括号不匹配&quot;); return 0; &#125; &#125; &#125; &#125; //如果所有括号匹配完成，栈内为空，说明所有括号全部匹配成功 if (top!=-1) &#123; printf(&quot;括号不匹配&quot;); &#125;else&#123; printf(&quot;括号匹配&quot;); &#125;&#125; 运行结果请输入括号序列：{}(){ 括号不匹配]]></content>
  </entry>
  <entry>
    <title><![CDATA[CTF的常见write up]]></title>
    <url>%2F2018%2F10%2F12%2FCTF%2F</url>
    <content type="text"><![CDATA[本文总结了CTF中我所遇到的题型及其write up，本文长期更新 希望各位多多评论指正，也算作对我第一次写技术文章的鼓励！ 训练场：南京邮电大学CTF题库 直接查看源码出现场景：一般出现在第一题 write up： 直接Ctrl+u查看网页源码寻找flag 修改maxlength出现场景：输入框输入内容有位数限制 write up：F12进入开发者模式修改maxlength后提交 PHP弱类型一、类型一介绍：PHP在处理哈希字符串时，会利用“!=”或“==”来对哈希值进行比较，它把每一个以”0e”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0e”开头的，那么PHP将会认为他们相同，都是0 出现场景：PHP代码审计、含md5的题 write up： 修复方法：“===”和“!==”strict比较符，只有在类型相同时才相等。“==”和“!=”即non-strict比较符，会在类型转换后进行比较 扩展：0e开头MD5值小结 string md5() s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 二、类型二源码： 1234567if (isset($_GET[&apos;a&apos;]) and isset($_GET[&apos;b&apos;])) &#123;if ($_GET[&apos;a&apos;] != $_GET[&apos;b&apos;])if (md5($_GET[&apos;a&apos;]) == md5($_GET[&apos;b&apos;]))die(&apos;Flag: &apos;.$flag);elseprint &apos;Wrong.&apos;;&#125; 分析：$_GET可以接受数组但MD5()函数若传递进去一个数组，则会返回null.因此向$_GET数组传入两个名为a、b的不相等的数组从而导致md5()均返回空:index.php?a[]=1&amp;b[]=2（即null=null） 脑洞题 源码找url 源码看flag jjencode/aaencode（颜文字）介绍： 什么是jjencode? 将js代码转换成只有符号的字符串 什么是aaencode？ 将js代码转换成常用的网络表情 aaencode加密：http://utf-8.jp/public/aaencode.html 解密方法：可以直接利用浏览器的控制台输入密文，执行后即可解密。 文件包含漏洞典型的文件包含漏洞的格式网址：php?file=xxx.php 原因：网页后端php（或其他）代码中使用了include等文件包含语句，而且所包含的文件由变量控制，恰恰此变量又能通过GET或POST等方式进行修改所造成的 利用方法：构建file=php://filter/read=convert.base64-encode/resource=index.php 注：其中index.php可以为任意已包含文件返回base64加密过的index.php文件源码。 注意：python3中base64的解密为base64.b64decode() mysql 精度问题 intval（）这个函数的作用是把参数自动转换成整数（int） $id = intval(1024.5)//结果为$id==1024 robots.txt介绍：robots.txt是搜索引擎中访问网站的时候要查看的第一个文件，robots.txt文件告诉了蜘蛛程序在服务器上什么文件是可以被查的。 %00分析源码： 涉及漏洞：查到资料 1.ereg会把null视为字符串的结束，从而被%00截断，而strpos则可以越过%00 2.当ntf为数组时它的返回值不是FALSE 利用方法： 1.?nctf=1%00%23biubiubiu 2.?nctf[]=1 变量覆盖源码：123456789&lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; ?&gt; &lt;div class=&quot;alert alert-success&quot;&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php &#125; ?&gt;&lt;?php &#125; ?&gt; 分析：extract()函数的作用：从数组中将变量导入到当前的符号表 可以看到这里的代码为：extract($_POST)，即将POST的参数导入当前的符号表 由于extract()函数存在变量覆盖漏洞，所以提交post参数： pass=123&amp;thepassword_123=123//或者pass[]=&amp;thepassword_123 即:将两个变量的值修改成相同的，即可得到flag！ 上传绕过源码：123456789文件上传&lt;br&gt;&lt;br&gt;&lt;form action=&quot;upload.php&quot; method=&quot;post&quot;enctype=&quot;multipart/form-data&quot;&gt;&lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;&lt;input type=&quot;hidden&quot; name=&quot;dir&quot; value=&quot;/uploads/&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; 一、0x00截断绕过方法：在burpsuite—Hex中，将空格php后面一个字符的hex修改为00 SQL注入一、GBK宽字节编码漏洞(gbk_sql_injection)介绍：php中MYSQL数据库,如果是GBK编码.一定要小心GBK宽字节编码漏洞正常情况下 magic_quote_gpc 为ON,如果输入 http://www.xxxx.com/index.php?user=11′ and 1=2 # SQL语句就会变成 SELECT * FROM user WHERE user=’1\’ and 1=2 #’ 自动加上了\转义，如果构造特殊的宽字节编码呢？ http://www.xxxx.com/index.php?user=11%df%27 and 1=2 # SQL语句就变成 SELECT * FROM user WHERE user=’11運’ and 1=2#’ 这样就注入上了！ 11%df会被解析成“11運”,而“%27”被邪恶的解析成’就绕过了gpc转义,就成功构造注入了 ### 二、正常情况1.情况1源码：1234567891011121314151617&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=&quot;select user from ctf where (user=&apos;&quot;.$user.&quot;&apos;) and (pw=&apos;&quot;.$pass.&quot;&apos;)&quot;; echo &apos;&lt;/br&gt;&apos;.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==&quot;admin&quot;) &#123; echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;; &#125; if($query[user] != &quot;admin&quot;) &#123; echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;); &#125;&#125;echo $query[user]; 分析：会对传入参数两端去空格，然后sql拼接如下 $sql=”select user from ctf where (user=’”.$user.”‘) and (pw=’”.$pass.”‘)”; 所以只要用构造一下user的值，使语法无误，然后注释掉后面的即可。 MySQL主要有三种注释方式： 注释方式 说明 # 注释到行尾 /*内容*/ 用于行间或多行注释 – 也是注释到行尾，但需要注意的是在两个减号后面至少要有一个\s，也就是空格，TAB，换行符等（’ or 1=1– ） 解法：本题可post： user=admin’)– -&amp;pass=123或user=admin’)#&amp;pass=123 sql语句就变成 select user from ctf where (user=’admin’)#’ and (pw=’123’) 查询语句就能成功返回user列，值为admin的那条记录。 2.union查询源码：123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&apos;$user&apos;&quot;));//关键点 if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123;//关键点 echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;; &#125; else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125;&#125;?&gt; 解法：关键点在源代码中我已经标出来。首先要观察，我们能够控制的查询结果有：$query[pw]的值，通过让union前的查询语句为空，查询结果由union后面的语句控制即可。例如： select pw from ctf where user=’-1’ union select ‘mytest’ 这样查询结果pw就是’mytest’这个字符串了。再看那个if语句，只看后面的判断，实际上只要输入的和查询的结果一致就行了。注意别忘记输入pass后，会对其进行MD5加密。所以构造post： user=’ union select md5(‘suqir’)#&amp;pass=suqir SELECT * FROM users WHERE name=’admin’ AND pass=’pass’; 3.转义源码：1234567891011121314151617181920212223&lt;!--#GOAL: login as admin,then get the flag;error_reporting(0);require &apos;db.inc.php&apos;;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&apos;username&apos;]);$password = @clean((string)$_GET[&apos;password&apos;]);$query=&apos;SELECT * FROM users WHERE name=\&apos;&apos;.$username.&apos;\&apos; AND pass=\&apos;&apos;.$password.&apos;\&apos;;&apos;;$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die(&apos;Invalid password!&apos;);&#125;echo $flag;--&gt; 分析：这题的clean函数用来过滤引号，会将其转化为实体编码，所以我们没有办法直接用引号来闭合了，只能运用转义字符来吃掉后面的那个单引号了 未完待续。。。]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
</search>
