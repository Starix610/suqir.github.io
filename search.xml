<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[对某视频解析软件的逆向分析]]></title>
    <url>%2F2020%2F03%2F07%2F%E5%AF%B9%E6%9F%90%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[该app使用了Lua脚本并进行了加密，借此机会实践一下Lua脚本解密 0x00 前言最近偶然发现一款全网视频解析的软件，安装后发现首页有影响使用体验的广告存在（现在作者已取消广告），同时其附加功能需要加群获取密码才能使用。借这个机会尝试通过逆向工程分析其逻辑，同时这个App使用了Lua脚本并进行了加密，也借此机会实践一下Lua脚本的解密 软件的原始版本下载：原始版本 软件截图 首页 VIP功能 VIP功能 0x01 工具 apktool—可以将apk资源解码，并在修改后可以重新构建它们，它还可以执行一些自动化任务，例如构建apk unluac.jar—是一个lua脚本反编译工具，适用于反编译lua开发的程序源码 0x02 分析过程 使用Apktool对其进行解包，解包到App目录下1apktool.bat d VIP终结者_5.2.2.apk -o App 执行完毕后进入App目录下 其中： assets：存放资源文件，包含Lua脚本 lib：本地库(Native Library)文件夹，包含编译后的本地代码(Native Code)的so文件 smail：存放smail文件，包含Dalvik字节码，是对App的Java代码反编译成字节码的结果 AndroidManifest.xml：包含App的信息 分析smail进入smail文件夹可以看到Java代码的结构： 发现存在com.androlua、com.luajava等包名，经搜索相关项目，判断App的大部分代码均来自AndroLua_pro。而AndroLua_pro是一个使用Lua语言编写的Android应用的项目，所以，Java代码极有可能并不是应用的主体部分，重要操作很有可能会写在Lua中，所以下面重点分析Lua脚本部分。 初步分析Lua进入assets可以看到里面存放了所有的Lua脚本及App的图片资源： 用winhex打开lua脚本: 发现并不是Lua明文代码，也不是编译后的luac文件。由此得知Lua脚本被加密了，需要对其进行解密 解密LuaAndroLua_Pro所使用的Lua工具LuaJava会加载依赖库libluajava.so，LuaJava会使用luaL_loadbuffer或者luaL_loadbufferx函数对Lua脚本进行加载，这个函数也是加入Lua脚本解密代码的常见位置，所以找到lib/armeabi/libluajava.so，用IDA打开并找到这个函数，按F5进行进一步分析： （上图为方便阅读，已反混淆变量名） 与AndroLua_Pro的原始代码比较，可以发现加入了Lua脚本解密的代码，分析该代码发现有一个IDA无法识别的函数sub_265E0(t, 255)，由于对IDA工具还有很多不懂的地方，故没有深入研究，初步猜测是t对255的取余运算（后面验证确实如此）。我们可以参考这一代码，使用C语言编写一个简单的解密工具： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;unsigned char *decrypt(const unsigned char *buff, size_t size) &#123; unsigned char *buff1 = (unsigned char *) malloc(size); buff1[0] = 27; int t = 0; for (int i = 1; i &lt; size; i++) &#123; t += size; buff1[i] = buff[i] ^ (t % 255); &#125; return buff1;&#125;unsigned char buff[204800];int main(int argc, char *argv[]) &#123; char filename[20] = "main.lua"; if (argc == 2) strcpy(filename,argv[1]); printf("File name: %s \n", filename); FILE *fp = fopen(filename, "rb"); size_t size = 0; size = fread(buff, sizeof(unsigned char), 204800, fp); printf("File size: %ld \n", size); unsigned char *res = decrypt(buff, size); strcat(filename, "c"); FILE *fp1 = fopen(filename, "wb"); fwrite(res, sizeof(unsigned char), size, fp1); printf("Output: %s", filename); return 0;&#125; 编译这一代码为decrypt.exe，并拷贝到assets文件夹下，执行以下命令来解密config.lua脚本： 1decrypt.exe config.lua 解密后的文件为config.luac，使用文本编辑器观察可以发现其仍然不是Lua代码，而是编译后的luac文件，我们还需要使用unluac.jar对其进行反编译。 1java -jar unluac.jar --rawstring config.luac &gt; config_new.lua (如果原始的源码中含有中文，需使用--rawstring参数进行解码) 反编译后的config.lua脚本内容如下： 对Lua脚本的修改不是本文探讨的重点，故不做分析。 使用如下命令进行打包： 1apktool b App –o out/newApp.apk 打包后的apk文件没有签名是不能安装到手机上的，需要使用其他的签名工具来对apk签名如signapk.jar、auto-sign等 0x03 结语本文分析了在Android中Lua脚本的解密过程，可以看到，软件的开发和逆向分析虽然看似处于对立的层面，但是双方的博弈过程却又促进着各自的发展，这使得开发人员更加重视软件的安全性，逆向工程师们也与时俱进的学习新的知识来面对越来越复杂的安全工作。随着国家现在越来越重视互联网安全问题，很多法律法规的出台来约束互联网规范，我们更应该重视安全对于各行各业的影响和机遇。]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>逆向</tag>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取某书网指定小说-微信版]]></title>
    <url>%2F2018%2F12%2F15%2F%E7%88%AC%E5%8F%96%E6%9F%90%E4%B9%A6%E7%BD%91%E6%8C%87%E5%AE%9A%E5%B0%8F%E8%AF%B4-%E5%BE%AE%E4%BF%A1%E7%89%88%2F</url>
    <content type="text"><![CDATA[服务器版的小说爬虫，并借助python的itchat库实现微信对话式小说下载服务 0x00 实现功能微信端发送小说名到指定微信号（格式：小说名suqir作者），服务器开始在全书网(http://www.quanshuwang.com)爬取该小说，爬取完成后将询问是否下载，确认后将通过微信以文件的形式发送 0x01 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#!/usr/bin/python#coding:utf-8import urllib.requestimport requests,reimport itchatfrom itchat.content import *class BookSpyder(object): """爬取指定小说-server版""" def __init__(self, book_name,book_author): super(BookSpyder, self).__init__() self.book_author = book_author self.headers = &#123;'User-Agent': 'User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'&#125; self.url = 'http://www.quanshuwang.com/modules/article/search.php?searchkey='+urllib.request.quote(book_name.encode('gb2312'))+'&amp;searchtype=articlename&amp;searchbuttom.x=88&amp;searchbuttom.y=22' search_data = requests.get(self.url,headers=self.headers,allow_redirects=False) try: # 搜索结果唯一时 self.location = search_data.headers['location'].split() self.location2res(self.location[0]) except KeyError: self.location = re.findall(r'&lt;li&gt;&lt;a target="_blank" href="(.*?)".*?title="(.*?)".*&gt;(.*?)&lt;/a&gt;&lt;em class=.*?&gt;(.*?)&lt;a href=',search_data.content.decode('gbk')) for http in self.location: flag = self.location2res(http[0]) if flag == 1: break #link self.booklink = re.findall(r'class="leftso png_bg"&gt;&lt;a href="(.*?)"',self.res)[0] #正则匹配书名 self.book_name = re.findall(r'&lt;meta property="og:title" content="(.*?)"/&gt;',self.res)[0] response = requests.get(self.booklink,headers=self.headers).content.decode('gbk') #正则匹配所有章节及其链接 self.contents = re.findall(r'&lt;li&gt;&lt;a href="(.*?)" title="(.*?)"&gt;.*?&lt;/a&gt;&lt;/li&gt;',response) #总章数 self.len = len(self.contents) def location2res(self,location): flag = -1 self.res = requests.get(location,headers=self.headers).content.decode('gbk') author = re.findall(r'&lt;meta property="og:novel:author" content="(.*?)"',self.res)[0] if self.book_author == author: flag = 1 try: self.description = re.findall(r'介绍:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;/div&gt;',self.res,re.S)[0].replace('&amp;nbsp;','').replace('&lt;br /&gt;','') except IndexError: pass return flag def save(self): i = 0 #开始写入文件 with open('./book/suqir.txt','w',encoding='utf-8',errors='ignore') as text_save: text_save.write(self.book_name+'\n作者：'+self.book_author) if 'self.description' in dir(): text_save.write('\n简介：'+self.description) text_save.write('\n') for num in self.contents: #获取单章文本 text_r = requests.get(num[0],headers=self.headers) text_c = text_r.content text = text_c.decode('gb18030') #获取章节名 title = num[1].replace(re.findall(r'，共\d*字',num[1])[0],'') try: #正则匹配内容 text = re.findall(r'&lt;/script&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;script type="text/javascript"&gt;',text,re.S)[0] #数据清洗 text = text.replace('&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;','') text = text.replace('&lt;br /&gt;','') text = text.replace('\r\n\r\n','\r\n') text_save.write('\n') text_save.write(title) text_save.write('\n\n') text_save.write(text) text_save.write('\n') print('[*]%-30s\t完成度%.3f%%'%(title,(i+1) * 100 / self.len)) i += 1 except IndexError as e: print('【*】%s下载失败'%title) text_save.write('\n===全书完===\n==by苏乞儿==\n') def get_bookname(self): return self.book_name def get_bookauthor(self): return self.book_author def get_des(self): try: return self.description except AttributeError: return '无简介' def get_centents(self): return self.len def get_booklink(self): return self.booklinkdef getUserName(): itchat.auto_login(hotReload=True,enableCmdQR=2) onlyUser = itchat.search_friends(name='杰帅') return onlyUser[0]['UserName']@itchat.msg_register([TEXT],isFriendChat=True)def text_reply(msg): global userName if msg['FromUserName'] == userName: try: bookName,bookAuthor = msg['Text'].split('suqir') book = BookSpyder(bookName,bookAuthor) itchat.send('书名：%s\n作者：%s\n简介：%s' % (bookName,bookAuthor,book.get_des()),toUserName=userName) itchat.send('正在爬取《%s》...' % bookName,toUserName=userName) print('[*]正在爬取《%s》...' % bookName) book.save() itchat.send('爬取完毕！是否下载？(是/否)',toUserName=userName) except ValueError: if msg['Text'] == '是': print('[*]正在发送文件...') itchat.send('正在上传...',toUserName=userName) itchat.send_file('./book/suqir.txt',toUserName=userName) print('[*]已发送文件！\n等待下次请求...') itchat.send('感谢使用！',toUserName=userName) elif msg['Text'] == '否': itchat.send('已取消，感谢使用！',toUserName=userName)if __name__ == '__main__': print('[*]Starting...') userName = getUserName() itchat.run() 0x02 运行部分截图服务器端 客户端]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>itchat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用微信实现小说更新提醒]]></title>
    <url>%2F2018%2F11%2F26%2F%E5%88%A9%E7%94%A8%E5%BE%AE%E4%BF%A1%E5%AE%9E%E7%8E%B0%E5%B0%8F%E8%AF%B4%E6%9B%B4%E6%96%B0%E6%8F%90%E9%86%92%2F</url>
    <content type="text"><![CDATA[人生最痛苦的事莫过于小说断更！这篇文章将对这一问题给出一种Python+阿里云+微信的解决方法不过世界总是需要懒人的，因为有了懒人创造世界。这话不是我说的，是马爸爸说的： 懒不是傻懒，如果你想少干，就要想出懒的方法。要懒出风格，懒出境界。——马云 为此我专门买了一台服务器（9.9还包邮哦），反正以后还有很多地方用到服务器。 扯远了。。。利用服务器可以干很多事，比如接下来的利用微信第三方python库实现小说更新时通过微信将更新内容发给指定朋友。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/python#coding:utf-8import time,itchat # 微信登录def vxLogin(rename): # enableCmdQR：在命令行中显示登录二维码，参数2是Linux系统下的字符宽度 itchat.auto_login(hotReload=True,enableCmdQR=2) friends = itchat.get_friends(update=True) for friend in reversed(friends): if friend['RemarkName'] == rename: toName = friend['UserName'] return toName# 检查更新def update(url,start,toName): import requests,re res = requests.get(url).content.decode('gb18030') lis = re.findall(r'&lt;li&gt;&lt;a href="(.*?)" title="(.*?)，.*?"&gt;',res) toName = vxLogin(rename=toName) for li in lis[start:]: end_str = li[1] try: end = int(re.findall(r'第[ ]?(.*?)[ ]?章',end_str)[0]) except ValueError: print('[*]小说更新了，但是章节序号为中文，我暂时不想处理。。。') #碰到这种情况再更新，懒 exit() if end &gt;= start+1: text = requests.get(li[0]).content.decode('gbk') re_text = re.findall(r'&lt;/script&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;script',text,re.S)[0] re_text = re_text.replace('&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;','') re_text = re_text.replace('&lt;br /&gt;','') re_text = re_text.replace('\r\n\r\n','\r\n') re_text = '%s\n%s\n\n' %(li[1],re_text) print('更新：%s' % li[1]) text = '最近更新了第%s章\n%s' % (end,re_text) length = len(text)//3 # 分3段发送 itchat.send(msg=text[:length], toUserName=toName) itchat.send(msg=text[length:(length*2)], toUserName=toName) itchat.send(msg=text[(length*2):], toUserName=toName) time.sleep(5) print('[*]更新完成！暂无最新章节') # 声明startNum为全局变量，这样就不会在这个函数内部新建变量 global startNum startNum = end time.sleep(3600)# 1小时更新检查一次if __name__ == '__main__': print('[*]Starting...') # 当前最新章节 startNum = 410 while True: update(url='http://www.quanshuwang.cn/book/137/137120',start=startNum,toName='杰帅')# toName为None时发给自己 # 持续运行 itchat.run() 这里的urlhttp://www.quanshuwang.cn/book/137/137120是我看的《一步偷天》在全书网的网址 运行结果服务器端： 微信端： 小说也看完了，终于又可以开始写bug了！！ 另外，这个博客只作分享交流技术用，大爷们不用打赏，真的不用，真的不用，（疯狂暗示中…）]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取某书网指定小说]]></title>
    <url>%2F2018%2F11%2F07%2F%E7%88%AC%E5%8F%96%E6%9F%90%E4%B9%A6%E7%BD%91%E6%8C%87%E5%AE%9A%E5%B0%8F%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[初探Python - 用Python实现对小说的爬取并下载 0x00 起因最近看了一部基于小说改编的电视剧，闲的无聊就去看了看小说。但是大多数看书网站都有或多或少的广告，强迫症表示很难受，加之近来正在学习Python，便想着利用Python爬取小说的内容，远离广告的‘宠信’。 0x01 实现原理程序实现原理很简单，将用户输入的书名提交到全书网进行搜索，将返回的结果存在list中并展示给用户，对用户选择的书籍进行书籍内容的爬取，并写入文件。 0x02 存在的问题初次学习写这种爬虫，代码难免冗余难读，但关键部分均写有注释，在此分享出来以作交流。在实际操作过程中也遇到不少问题，比如：如果所查询的书籍在全书网中只有唯一的一本，全书网将直接通过location进行重定向到书籍详情页，与多本书的处理方式不一致，所以为了完美的获取书记简介必须写个if判断；再如：用户提交的书名必须经过gb2312编码并转urlencoding后才能查询到，否则服务器返回错误。。。不过，也可能是我第一次写，有更好的处理方法，希望自己继续努力吧！ 0x03 源代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151# -*- coding: utf-8 -*-import requests,sys,reimport urllib.requestclass Bookspider(object): """爬取全书网指定书籍并下载到本地""" def __init__(self): super(Bookspider, self).__init__() self.request = requests.session() self.headers = &#123; #随机指定user-agent 'User-Agent': 'User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36' &#125; def book_search(self,name): print('[*]搜索中...') #全书网的搜索url #对name进行url编码：urllib.request.quote self.url = 'http://www.quanshuwang.com/modules/article/search.php?searchkey='+urllib.request.quote(name.encode('gb2312'))+'&amp;searchtype=articlename&amp;searchbuttom.x=88&amp;searchbuttom.y=22' #禁止重定向：allow_redirects=False search_data = self.request.get(self.url,headers=self.headers,allow_redirects=False) try: #所爬书籍唯一时被重定向到location self.location = search_data.headers['location'] #将str的location转换成list，方便计算length self.location = self.location.split() except KeyError as e: response = search_data.content.decode('gbk') #所爬书籍有多种结果时，返回所有书籍信息 self.location = re.findall(r'&lt;li&gt;&lt;a target="_blank" href="(.*?)".*?title="(.*?)".*&gt;(.*?)&lt;/a&gt;&lt;em class=.*?&gt;(.*?)&lt;a href=',response) return self.location def book_info(self): res = requests.get(self.location,headers=self.headers).content.decode('gbk') #正则匹配书名 self.bookname = re.findall(r'&lt;meta property="og:title" content="(.*?)"/&gt;',res)[0] #正则匹配书籍作者 self.author = re.findall(r'&lt;meta property="og:novel:author" content="(.*?)"/&gt;',res)[0] #正则匹配书记简介 re.S指定多行匹配 self.description = re.findall(r'&lt;meta property="og:description" content="(.*?)"/&gt;',res,re.S)[0].replace('&amp;nbsp;','').replace('&lt;br /&gt;','').replace(' ','') #正则匹配书籍目录 self.booklink = re.findall(r'class="leftso png_bg"&gt;&lt;a href="(.*?)"',res)[0] response = requests.get(self.booklink,headers=self.headers).content.decode('gbk') #正则匹配所有章节及其链接 self.contents = re.findall(r'&lt;li&gt;&lt;a href="(.*?)" title="(.*?)"&gt;.*?&lt;/a&gt;&lt;/li&gt;',response) #总章数 self.len = len(self.contents) def save(self): i = 0 #开始写入文件 with open('%s.txt'%self.bookname,'w',encoding='utf-8',errors='ignore') as text_save: text_save.write(self.bookname+'\n作者：'+self.author) text_save.write('\n简介：'+self.description) text_save.write('\n') for num in self.contents: #获取单章文本 text_r = requests.get(num[0],headers=self.headers) text_c = text_r.content text = text_c.decode('gbk') #获取章节名 title = num[1].replace(re.findall(r'，共\d*字',num[1])[0],'') try: #正则匹配内容 text = re.findall(r'&lt;/script&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;script type="text/javascript"&gt;',text,re.S)[0] except IndexError as e: print('【**】%s下载失败'%title) #数据清洗 text = text.replace('&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;','') text = text.replace('&lt;br /&gt;','') text = text.replace('\r\n\r\n','\r\n') text_save.write('\n') text_save.write(title) text_save.write('\n\n') text_save.write(text) text_save.write('\n') print('[*]%-30s\t完成度%.3f%%'%(title,(i+1) * 100 / self.len)) i += 1 text_save.write('\n===全书完===\n==by苏乞儿==\n') def get_item(self): item = len(self.location) return item def set_location(self,location): self.location = location def get_bookname(self): return self.bookname def get_author(self): return self.author #获取总章数 def get_chapter(self): return self.len def get_description(self): return self.descriptionif __name__ == '__main__': book = Bookspider() name = input('[*]请输入书名：') #查书 locations = book.book_search(name) item_sum = book.get_item() #以下为两种搜索结果的处理，1.所爬的书籍在全书网是唯一的，2.所爬的书籍在全书网有多本 if item_sum == 1: book.set_location(locations[0]) book.book_info() print('[*]%s共%d条搜索结果：\n'%(name,item_sum)) print('#'*150) print('[*]书名：%s'%book.get_bookname()) print('[*]作者：%s'%book.get_author()) print('[*]简介：%s'%book.get_description()) print('#'*150) choose1 = input('[*]是否继续下载？(y/n)') if choose1 == 'y' or choose1 == 'Y': print('\n[*]正在下载《%s》'%book.get_bookname()) #保存文本 book.save() else: print('\n[*]感谢使用！') sys.exit(1) else: j = 0 print('[*]%s共%d条搜索结果：\n'%(name,item_sum)) for item in locations: print('#'*150) print('[*]序号：%d'%(j+1)) print('[*]书名：%s'%item[1]) print('[*]作者：%s'%item[2]) print('[*]简介：%s'%item[3]) print('#'*150) j +=1 choose2 = int(input('\n\n请选择序号：')) if choose2 &gt;= 1 and choose2 &lt;= item_sum: print('\n[*]正在下载《%s》'%locations[choose2-1][1]) #设置书籍链接地址 book.set_location(locations[choose2-1][0]) book.book_info() #保存文本 book.save() else: print('\n[*]感谢使用！') sys.exit(1) print('\n[*]下载成功！') 0x04 部分运行截图： 0x05 下载的文本文件： 0x06 更新（2018年11月26日）后期使用过程发现还有不少bug，不过毕竟算第一篇爬虫，这边就不删除了，留个纪念吧！较完善的服务器版本在这里：爬取某书网指定小说-微信版]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次CTF大赛的感受]]></title>
    <url>%2F2018%2F10%2F29%2F%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E5%A4%A7%E8%B5%9B%E7%9A%84%E6%84%9F%E5%8F%97%2F</url>
    <content type="text"><![CDATA[对山东省网络技术大赛的参赛体会和总结 0x00 前言10月27号的山东省网络技术大赛是我大学参加过的第一个比赛，在这个比赛中我和各大高校的大佬们共同在网络攻防CTF夺旗赛这一命题中进行角逐。其实在去之前我的心里是没有多少信心的（事实证明我的担心是有必要的），同时寄希望于其他选手水平也差不多，我也只看过一些基础的web方向的解题方法，只看过几篇关于隐写的题，因为在我看来这种比赛应该不会涉及到密码，逆向，溢出和隐写等等这几类题，然而。。。 先分享一下我比赛最后的排名情况： 我的成绩在里面不是特别理想，在39名选手中排在第11位，得分仅331，与前三名一千多的得分更是有着不小的差距（小声哔哔：前三是来自警察学院的未来的网警），但究其根本还是自己在网络安全这一领域还有很长的路要走。 下面是在这次比赛中我得到的一些经验和教训，特地分享出来，一来警示自己，二来以作交流。另外，我会在后面把所有题做一遍并写一篇write up(如果官方还没有关闭训练场) 0x01 不足 过分自信，轻视对手 解题时心静不下来，导致做题时没有深入，往往错过很多会做的题 没有设立明确的目标，导致会的题因为较其他选手稍晚得到flag，得分较低；不会的题又没有尝试去解 在网络安全领域坐井观天，没有保持一颗学习的心态 0x02 受益 心中始终坚信：学无止境 积累了大赛经验，后续参加此类比赛不至于手忙脚乱 坚守自己的底线 0x03 展望在经历了此次比赛后，虽然没有取得满意的成绩，但也更加坚定了对未来继续扩展学习方向的信心。接下来的近一年时间，我将根据时间安排准备下一届的网络安全大赛，同时进行PHP、Python等语言的学习，争取将各个CTF大赛的题看一遍write up或自己试解，希望能在下一届的比赛中获得一个令自己比较满意的成绩。 人生没有退路，只有不停地选择！]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF]]></title>
    <url>%2F2018%2F10%2F12%2FCTF%2F</url>
    <content type="text"><![CDATA[本文总结了CTF中我所遇到的题型及其write up，本文长期更新 希望各位多多评论指正，也算作对我第一次写技术文章的鼓励！ 训练场：南京邮电大学CTF题库 直接查看源码出现场景：一般出现在第一题 write up： 直接Ctrl+u查看网页源码寻找flag 修改maxlength出现场景：输入框输入内容有位数限制 write up：F12进入开发者模式修改maxlength后提交 IP伪造各种伪造IP的HTTP头： 序号 伪造方式 1 X-Forwarded-For 2 Client-IP 3 x-remote-IP 4 x-originating-IP 5 x-remote-addr 进制转换源码： 123456789101112131415161718192021&lt;?phpfunction noother_says_correct($number)&#123; $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == '54975581388';&#125;$flag='*******';if(noother_says_correct($_GET['key'])) echo $flag;else echo 'access denied';?&gt; 分析：要求传入key不包含数字[1-9]，但又等于54975581388，考虑转十六进制，发现54975581388=0xccccccccc,因此get方法传值key=0xccccccccc PHP弱类型类型一介绍：PHP在处理哈希字符串时，会利用“!=”或“==”来对哈希值进行比较，它把每一个以”0e”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0e”开头的，那么PHP将会认为他们相同，都是0 出现场景：PHP代码审计、含md5的题 write up： 修复方法：“===”和“!==”strict比较符，只有在类型相同时才相等。“==”和“!=”即non-strict比较符，会在类型转换后进行比较 扩展：0e开头MD5值小结 string md5() s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 类型二源码： 1234567if (isset($_GET['a']) and isset($_GET['b'])) &#123;if ($_GET['a'] != $_GET['b'])if (md5($_GET['a']) == md5($_GET['b']))die('Flag: '.$flag);elseprint 'Wrong.';&#125; 分析：$_GET可以接受数组但MD5()函数若传递进去一个数组，则会返回null.因此向$_GET数组传入两个名为a、b的不相等的数组从而导致md5()均返回空:index.php?a[]=1&amp;b[]=2（即null=null） 脑洞题 源码找url 源码看flag jjencode/aaencode（颜文字）介绍： 什么是jjencode? 将js代码转换成只有符号的字符串 什么是aaencode？ 将js代码转换成常用的网络表情 aaencode加密：http://utf-8.jp/public/aaencode.html 解法：可以直接利用浏览器的控制台输入密文，执行后即可解密。 文件包含漏洞典型的文件包含漏洞的格式网址：php?file=xxx.php 原因：网页后端php（或其他）代码中使用了include等文件包含语句，而且所包含的文件由变量控制，恰恰此变量又能通过GET或POST等方式进行修改所造成的 利用方法：构建file=php://filter/read=convert.base64-encode/resource=index.php 注：其中index.php可以为任意已包含文件返回base64加密过的index.php文件源码。 注意：python3中base64的解密为base64.b64decode() mysql 精度问题 intval()这个函数的作用是把参数自动转换成整数（int） $id = intval(1024.5)//结果为$id==1024 robots.txt介绍：robots.txt是搜索引擎中访问网站的时候要查看的第一个文件，robots.txt文件告诉了蜘蛛程序在服务器上什么文件是可以被查的。 %00源码： 12345678if (isset ($_GET['nctf'])) &#123; if (@ereg ("^[1-9]+$", $_GET['nctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~';&#125; 涉及漏洞：查到资料 1.ereg会把null视为字符串的结束，从而被%00截断，而strpos则可以越过%00 2.当ntf为数组时它的返回值不是FALSE 利用方法： 1.?nctf=1%00%23biubiubiu 2.?nctf[]=1 变量覆盖源码： 123456789&lt;?php if ($_SERVER["REQUEST_METHOD"] == "POST") &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; ?&gt; &lt;div class="alert alert-success"&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php &#125; ?&gt;&lt;?php &#125; ?&gt; 分析：extract()函数的作用：从数组中将变量导入到当前的符号表 可以看到这里的代码为：extract($_POST)，即将POST的参数导入当前的符号表 由于extract()函数存在变量覆盖漏洞，所以提交post参数： pass=123&amp;thepassword_123=123//或者pass[]=&amp;thepassword_123 即:将两个变量的值修改成相同的，即可得到flag！ 上传绕过源码： 123456789文件上传&lt;br&gt;&lt;br&gt;&lt;form action="upload.php" method="post"enctype="multipart/form-data"&gt;&lt;label for="file"&gt;Filename:&lt;/label&gt;&lt;input type="hidden" name="dir" value="/uploads/" /&gt;&lt;input type="file" name="file" id="file" /&gt; &lt;br /&gt;&lt;input type="submit" name="submit" value="Submit" /&gt;&lt;/form&gt; 0x00截断绕过方法：在burpsuite—Hex中，将空格php后面一个字符的hex修改为00 SQL注入常规注入正常闭合源码： 1234567891011121314151617&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql="select user from ctf where (user='".$user."') and (pw='".$pass."')"; echo '&lt;/br&gt;'.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]=="admin") &#123; echo "&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;"; &#125; if($query[user] != "admin") &#123; echo("&lt;p&gt;You are not admin!&lt;/p&gt;"); &#125;&#125;echo $query[user]; 分析：会对传入参数两端去空格，然后sql拼接如下 $sql=&quot;select user from ctf where (user=&#39;&quot;.$user.&quot;&#39;) and (pw=&#39;&quot;.$pass.&quot;&#39;)&quot;; 所以只要用构造一下user的值，使语法无误，然后注释掉后面的即可。 MySQL主要有三种注释方式： 注释方式 说明 # 注释到行尾 /*内容*/ 用于行间或多行注释（也可用/**/代替空格） – 也是注释到行尾，但需要注意的是在两个减号后面至少要有一个\s，也就是空格，TAB，换行符等（’ or 1=1– ） 解法：本题可post：user=admin&#39;)-- -&amp;pass=123或user=admin&#39;)#&amp;pass=123 sql语句就变成select user from ctf where (user=&#39;admin&#39;)#&#39; and (pw=&#39;123&#39;) 查询语句就能成功返回user列，值为admin的那条记录。 union查询源码： 123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query("select pw from ctf where user='$user'")); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; echo "&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;"; &#125; else &#123; echo("&lt;p&gt;Log in failure!&lt;/p&gt;"); &#125;&#125;?&gt; 解法：关键点在源代码第7、8行。首先要观察，我们能够控制的查询结果有$query[pw]的值，通过让union前的查询语句为空，查询结果由union后面的语句控制即可。 例如：select pw from ctf where user=&#39;-1&#39; union select &#39;mytest&#39;这样查询结果pw就是’mytest’这个字符串了。再看那个if语句，只看后面的判断，实际上只要输入的和查询的结果一致就行了。 注意别忘记输入pass后，会对其进行MD5加密。所以构造post：user=&#39; union select md5(&#39;suqir&#39;)#&amp;pass=suqir查询语句就变为SELECT * FROM users WHERE name=&#39;admin&#39; AND pass=&#39;pass&#39;; 转义源码： 1234567891011121314151617181920212223&lt;!--#GOAL: login as admin,then get the flag;error_reporting(0);require 'db.inc.php';function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET['username']);$password = @clean((string)$_GET['password']);$query='SELECT * FROM users WHERE name=\''.$username.'\' AND pass=\''.$password.'\';';$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die('Invalid password!');&#125;echo $flag;--&gt; 分析：这题的clean函数用来过滤引号，会将其转化为实体编码，所以我们没有办法直接用引号来闭合了，只能运用转义字符来吃掉后面的那个单引号了，即构造username=suqir\&amp;password=or%201%23使得查询语句如下 SELECT * FROM users WHERE name=&#39;suqir\&#39;&#39; AND pass=&#39;or%201%23&#39; 即 123456SELECT * FROM users WHERE name='suqir\' AND pass=' 『 [name]的值为 [' AND pass=] ，显然逻辑值为false 』or 1 『 但没关系，[false or 1] 的逻辑值为真』 #' 『 注释掉多余的单引号 』即select * from users where false or 1 一道综合题:南邮CTF-综合题2及其writeup GBK宽字节编码漏洞(gbk_sql_injection)介绍：php中MYSQL数据库,如果是GBK编码.一定要小心GBK宽字节编码漏洞正常情况下 magic_quote_gpc 为ON,如果输入 http://www.xxxx.com/index.php?user=11′ and 1=2 # SQL语句就会变成 SELECT * FROM user WHERE user=’1\’ and 1=2 #’ 自动加上了\转义，如果构造特殊的宽字节编码呢？ http://www.xxxx.com/index.php?user=11%df%27 and 1=2 # SQL语句就变成 SELECT * FROM user WHERE user=’11運’ and 1=2#’ 这样就注入上了！ 11%df会被解析成11運,而%27被邪恶的解析成&#39;就绕过了gpc转义,就成功构造注入了 Unix/Linux相关bash_historyBash shell在~/.bash_history（~/表示用户目录）文件中保存了500条使用过的命令，这样可以使你输入使用过的长命令变得容易。每个在系统中拥有账号的用户在他的目录下都有一个.bash_history文件。 为了安全，bash shell应该保存少量的命令，并且在每次用户注销时都把这些历史命令删除。 删除方法: 第一步：/etc/profile文件中的HISTFILESIZE和HISTSIZE行确定所有用户的.bash_history文件中可以保存的旧命令条数。强烈建议把把/etc/profile文件中的HISTFILESIZE和HISTSIZE行的值设为一个较小的数，比如30。编辑profile文件vi /etc/profile，把下面这行改为： 12HISTFILESIZE=30HISTSIZE=30 这表示每个用户的.bash_history文件只可以保存30条旧命令。 第二步：网管还应该在/etc/skel/.bash_logout文件中添加下面这行rm -f $HOME/.bash_history。这样，当用户每次注销时.bash_history文件都会被删除. vi编辑器的备份文件linux下一般使用vi编辑器，并且异常退出会留下备份文件xxx.swp 一句话木马数组回调后门源码： 12345&lt;?php$e = $_REQUEST['www'];$arr = array($_POST['wtf'] =&gt; '|.*|e',);array_walk($arr, $e, '');?&gt; 分析：利用了php中回调函数的后门，可以使www为preg_replace函数，当array_walk()将函数作用于数组时，POST传入的数据作为preg_replace()的第二个参数，在替换后被当做 php 代码执行（在php5.3下可用，5.5后preg_replace函数已弃用了使替换后的字符串作为php代码执行的/e修饰符）。 测试： 未完待续。。。]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
</search>
